{
    "file":"blockchain-explorer.json",
    "description":"Adds json rpc methods for block and transaction actions",
    "required":[ "core/bytecoin.json" ],
    "files": [ 
        {
            "path":"/src/Rpc/CoreRpcServerCommandsDefinitions.h",
            "changes": [
                {
                    "action":"add_above",
                    "marker":"struct COMMAND_RPC_GET_LAST_BLOCK_HEADER {",
                    "parameters": {
                        "text":[
                            "struct f_transaction_short_response {",
                            "  std::string hash;",
                            "  uint64_t fee;",
                            "  uint64_t amount_out;",
                            "  uint64_t size;",
                            "",
                            "  void serialize(ISerializer &s) {",
                            "    KV_MEMBER(hash)",
                            "    KV_MEMBER(fee)",
                            "    KV_MEMBER(amount_out)",
                            "    KV_MEMBER(size)",
                            "  }",
                            "};",
                            "",
                            "struct f_transaction_details_response {",
                            "  std::string hash;",
                            "  uint64_t receiveTime;",
                            "  size_t size;",
                            "  std::string paymentId;",
                            "  uint64_t mixin;",
                            "  uint64_t fee;",
                            "  uint64_t amount_out;",
                            "",
                            "  void serialize(ISerializer &s) {",
                            "    KV_MEMBER(hash)",
                            "    KV_MEMBER(receiveTime)",
                            "    KV_MEMBER(size)",
                            "    KV_MEMBER(paymentId)",
                            "    KV_MEMBER(mixin)",
                            "    KV_MEMBER(fee)",
                            "    KV_MEMBER(amount_out)",
                            "  }",
                            "};",
                            "",
                            "struct f_block_short_response {",
                            "  uint64_t timestamp;",
                            "  uint32_t height;",
                            "  std::string hash;",
                            "  uint64_t tx_count;",
                            "  uint64_t cumul_size;",
                            "",
                            "  void serialize(ISerializer &s) {",
                            "    KV_MEMBER(timestamp)",
                            "    KV_MEMBER(height)",
                            "    KV_MEMBER(hash)",
                            "    KV_MEMBER(cumul_size)",
                            "    KV_MEMBER(tx_count)",
                            "  }",
                            "};",
                            "",
                            "struct f_block_details_response {",
                            "  uint8_t major_version;",
                            "  uint8_t minor_version;  ",
                            "  uint64_t timestamp;",
                            "  std::string prev_hash;",
                            "  uint32_t nonce;",
                            "  bool orphan_status;",
                            "  uint64_t height;",
                            "  uint64_t depth;",
                            "  std::string hash;",
                            "  difficulty_type difficulty;",
                            "  uint64_t reward;",
                            "  uint64_t blockSize;",
                            "  size_t sizeMedian;",
                            "  uint64_t effectiveSizeMedian;",
                            "  uint64_t transactionsCumulativeSize;",
                            "  std::string alreadyGeneratedCoins;",
                            "  uint64_t alreadyGeneratedTransactions;",
                            "  uint64_t baseReward;",
                            "  double penalty;",
                            "  uint64_t totalFeeAmount;",
                            "  std::vector<f_transaction_short_response> transactions;",
                            "",
                            "  void serialize(ISerializer &s) {",
                            "    KV_MEMBER(major_version)",
                            "    KV_MEMBER(minor_version)",
                            "    KV_MEMBER(timestamp)",
                            "    KV_MEMBER(prev_hash)",
                            "    KV_MEMBER(nonce)",
                            "    KV_MEMBER(orphan_status)",
                            "    KV_MEMBER(height)",
                            "    KV_MEMBER(depth)",
                            "    KV_MEMBER(hash)",
                            "    KV_MEMBER(difficulty)",
                            "    KV_MEMBER(reward)",
                            "    KV_MEMBER(blockSize)",
                            "    KV_MEMBER(sizeMedian)",
                            "    KV_MEMBER(effectiveSizeMedian)",
                            "    KV_MEMBER(transactionsCumulativeSize)",
                            "    KV_MEMBER(alreadyGeneratedCoins)",
                            "    KV_MEMBER(alreadyGeneratedTransactions)",
                            "    KV_MEMBER(baseReward)",
                            "    KV_MEMBER(penalty)",
                            "    KV_MEMBER(transactions)",
                            "    KV_MEMBER(totalFeeAmount)",
                            "  }",
                            "};"
                        ]
                    }
                },
                {
                    "action":"add_above",
                    "marker":"struct COMMAND_RPC_QUERY_BLOCKS {",
                    "parameters": {
                        "text":[
                            "struct F_COMMAND_RPC_GET_BLOCKS_LIST {",
                            "  struct request {",
                            "    uint64_t height;",
                            "",
                            "    void serialize(ISerializer &s) {",
                            "      KV_MEMBER(height)",
                            "    }",
                            "  };",
                            "",
                            "  struct response {",
                            "    std::vector<f_block_short_response> blocks; //transactions blobs as hex",
                            "    std::string status;",
                            "",
                            "    void serialize(ISerializer &s) {",
                            "      KV_MEMBER(blocks)",
                            "      KV_MEMBER(status)",
                            "    }",
                            "  };",
                            "};",
                            "",
                            "struct F_COMMAND_RPC_GET_BLOCK_DETAILS {",
                            "  struct request {",
                            "    std::string hash;",
                            "",
                            "    void serialize(ISerializer &s) {",
                            "      KV_MEMBER(hash)",
                            "    }",
                            "  };",
                            "",
                            "  struct response {",
                            "    f_block_details_response block;",
                            "    std::string status;",
                            "",
                            "    void serialize(ISerializer &s) {",
                            "      KV_MEMBER(block)",
                            "      KV_MEMBER(status)",
                            "    }",
                            "  };",
                            "};",
                            "",
                            "struct F_COMMAND_RPC_GET_TRANSACTION_DETAILS {",
                            "  struct request {",
                            "    std::string hash;",
                            "",
                            "    void serialize(ISerializer &s) {",
                            "      KV_MEMBER(hash)",
                            "    }",
                            "  };",
                            "",
                            "  struct response {",
                            "    Transaction tx;",
                            "    f_transaction_details_response txDetails;",
                            "    f_block_short_response block;",
                            "    std::string status;",
                            "",
                            "    void serialize(ISerializer &s) {",
                            "      KV_MEMBER(tx)",
                            "      KV_MEMBER(txDetails)",
                            "      KV_MEMBER(block)",
                            "      KV_MEMBER(status)",
                            "    }",
                            "  };",
                            "};"
                        ]
                    }
                }
            ]
        },
        {
            "path":"/src/Rpc/RpcServer.h",
            "changes": [
                {
                    "action":"add_above",
                    "marker":"#include \"CoreRpcServerCommandsDefinitions.h\"",
                    "parameters": {
                        "text":[
                            "#include \"Common/Math.h\""
                        ]
                    }
                },
                {
                    "action":"add_above",
                    "marker":"Logging::LoggerRef logger;",
                    "parameters": {
                        "text":[
                            "  bool f_on_blocks_list_json(const F_COMMAND_RPC_GET_BLOCKS_LIST::request& req, F_COMMAND_RPC_GET_BLOCKS_LIST::response& res);",
                            "  bool f_on_block_json(const F_COMMAND_RPC_GET_BLOCK_DETAILS::request& req, F_COMMAND_RPC_GET_BLOCK_DETAILS::response& res);",
                            "  bool f_on_transaction_json(const F_COMMAND_RPC_GET_TRANSACTION_DETAILS::request& req, F_COMMAND_RPC_GET_TRANSACTION_DETAILS::response& res);",
                            "  bool f_getMixin(const Transaction& transaction, uint64_t& mixin);"
                        ]
                    }
                }
            ]
        },
        {
            "path":"/src/Rpc/RpcServer.cpp",
            "changes": [
                {
                    "action":"add_above",
                    "marker":"{ \"getblockcount\", makeMemberMethod(&RpcServer::on_getblockcount) },",
                    "parameters": {
                        "text":[
                            "      { \"f_blocks_list_json\", makeMemberMethod(&RpcServer::f_on_blocks_list_json) },",
                            "      { \"f_block_json\", makeMemberMethod(&RpcServer::f_on_block_json) },",
                            "      { \"f_transaction_json\", makeMemberMethod(&RpcServer::f_on_transaction_json) },"
                        ]
                    }
                },
                {
                    "action":"add_above",
                    "marker":"bool RpcServer::on_getblockcount(const COMMAND_RPC_GETBLOCKCOUNT::request& req, COMMAND_RPC_GETBLOCKCOUNT::response& res) {",
                    "parameters": {
                        "text":[
                            "bool RpcServer::f_on_blocks_list_json(const F_COMMAND_RPC_GET_BLOCKS_LIST::request& req, F_COMMAND_RPC_GET_BLOCKS_LIST::response& res) {",
                            "  if (m_core.get_current_blockchain_height() <= req.height) {",
                            "    throw JsonRpc::JsonRpcError{ CORE_RPC_ERROR_CODE_TOO_BIG_HEIGHT,",
                            "      std::string(\"To big height: \") + std::to_string(req.height) + \", current blockchain height = \" + std::to_string(m_core.get_current_blockchain_height()) };",
                            "  }",
                            "",
                            "  uint32_t print_blocks_count = 30;",
                            "  uint32_t last_height = req.height - print_blocks_count;",
                            "  if (req.height <= print_blocks_count)  {",
                            "    last_height = 0;",
                            "  } ",
                            "",
                            "  for (uint32_t i = req.height; i >= last_height; i--) {",
                            "    Hash block_hash = m_core.getBlockIdByHeight(static_cast<uint32_t>(i));",
                            "    Block blk;",
                            "    if (!m_core.getBlockByHash(block_hash, blk)) {",
                            "      throw JsonRpc::JsonRpcError{ CORE_RPC_ERROR_CODE_INTERNAL_ERROR,",
                            "        \"Internal error: can't get block by height. Height = \" + std::to_string(i) + '.' };",
                            "    }",
                            "",
                            "    size_t tx_cumulative_block_size;",
                            "    m_core.getBlockSize(block_hash, tx_cumulative_block_size);",
                            "    size_t blokBlobSize = getObjectBinarySize(blk);",
                            "    size_t minerTxBlobSize = getObjectBinarySize(blk.baseTransaction);",
                            "",
                            "    f_block_short_response block_short;",
                            "    block_short.cumul_size = blokBlobSize + tx_cumulative_block_size - minerTxBlobSize;",
                            "    block_short.timestamp = blk.timestamp;",
                            "    block_short.height = i;",
                            "    block_short.hash = Common::podToHex(block_hash);",
                            "    block_short.cumul_size = blokBlobSize + tx_cumulative_block_size - minerTxBlobSize;",
                            "    block_short.tx_count = blk.transactionHashes.size() + 1;",
                            "",
                            "    res.blocks.push_back(block_short);",
                            "",
                            "    if (i == 0)",
                            "      break;",
                            "  }",
                            "",
                            "  res.status = CORE_RPC_STATUS_OK;",
                            "  return true;",
                            "}",
                            "",
                            "bool RpcServer::f_on_block_json(const F_COMMAND_RPC_GET_BLOCK_DETAILS::request& req, F_COMMAND_RPC_GET_BLOCK_DETAILS::response& res) {",
                            "  Hash hash;",
                            "",
                            "  if (!parse_hash256(req.hash, hash)) {",
                            "    throw JsonRpc::JsonRpcError{",
                            "      CORE_RPC_ERROR_CODE_WRONG_PARAM,",
                            "      \"Failed to parse hex representation of block hash. Hex = \" + req.hash + '.' };",
                            "  }",
                            "",
                            "  Block blk;",
                            "  if (!m_core.getBlockByHash(hash, blk)) {",
                            "    throw JsonRpc::JsonRpcError{",
                            "      CORE_RPC_ERROR_CODE_INTERNAL_ERROR,",
                            "      \"Internal error: can't get block by hash. Hash = \" + req.hash + '.' };",
                            "  }",
                            "",
                            "  if (blk.baseTransaction.inputs.front().type() != typeid(BaseInput)) {",
                            "    throw JsonRpc::JsonRpcError{",
                            "      CORE_RPC_ERROR_CODE_INTERNAL_ERROR,",
                            "      \"Internal error: coinbase transaction in the block has the wrong type\" };",
                            "  }",
                            "",
                            "  block_header_response block_header;",
                            "  res.block.height = boost::get<BaseInput>(blk.baseTransaction.inputs.front()).blockIndex;",
                            "  fill_block_header_response(blk, false, res.block.height, hash, block_header);",
                            "",
                            "  res.block.major_version = block_header.major_version;",
                            "  res.block.minor_version = block_header.minor_version;",
                            "  res.block.timestamp = block_header.timestamp;",
                            "  res.block.prev_hash = block_header.prev_hash;",
                            "  res.block.nonce = block_header.nonce;",
                            "  res.block.hash = Common::podToHex(hash);",
                            "  res.block.depth = m_core.get_current_blockchain_height() - res.block.height - 1;",
                            "  m_core.getBlockDifficulty(static_cast<uint32_t>(res.block.height), res.block.difficulty);",
                            "",
                            "  res.block.reward = block_header.reward;",
                            "",
                            "  std::vector<size_t> blocksSizes;",
                            "  if (!m_core.getBackwardBlocksSizes(res.block.height, blocksSizes, parameters::CRYPTONOTE_REWARD_BLOCKS_WINDOW)) {",
                            "    return false;",
                            "  }",
                            "  res.block.sizeMedian = Common::medianValue(blocksSizes);",
                            "",
                            "  size_t blockSize = 0;",
                            "  if (!m_core.getBlockSize(hash, blockSize)) {",
                            "    return false;",
                            "  }",
                            "  res.block.transactionsCumulativeSize = blockSize;",
                            "",
                            "  size_t blokBlobSize = getObjectBinarySize(blk);",
                            "  size_t minerTxBlobSize = getObjectBinarySize(blk.baseTransaction);",
                            "  res.block.blockSize = blokBlobSize + res.block.transactionsCumulativeSize - minerTxBlobSize;",
                            "",
                            "  uint64_t alreadyGeneratedCoins;",
                            "  if (!m_core.getAlreadyGeneratedCoins(hash, alreadyGeneratedCoins)) {",
                            "    return false;",
                            "  }",
                            "  res.block.alreadyGeneratedCoins = std::to_string(alreadyGeneratedCoins);",
                            "",
                            "  if (!m_core.getGeneratedTransactionsNumber(res.block.height, res.block.alreadyGeneratedTransactions)) {",
                            "    return false;",
                            "  }",
                            "",
                            "  uint64_t prevBlockGeneratedCoins = 0;",
                            "  if (res.block.height > 0) {",
                            "    if (!m_core.getAlreadyGeneratedCoins(blk.previousBlockHash, prevBlockGeneratedCoins)) {",
                            "      return false;",
                            "    }",
                            "  }",
                            "  uint64_t maxReward = 0;",
                            "  uint64_t currentReward = 0;",
                            "  int64_t emissionChange = 0;",
                            "  bool penalizeFee = blk.majorVersion >= 2;",
                            "  size_t blockGrantedFullRewardZone = penalizeFee ?",
                            "  m_core.currency().blockGrantedFullRewardZone() :",
                            "   m_core.currency().blockGrantedFullRewardZoneV1();",
                            "  res.block.effectiveSizeMedian = std::max(res.block.sizeMedian, blockGrantedFullRewardZone);",
                            "",
                            "  if (!m_core.getBlockReward(res.block.sizeMedian, 0, prevBlockGeneratedCoins, 0, penalizeFee, maxReward, emissionChange)) {",
                            "    return false;",
                            "  }",
                            "  if (!m_core.getBlockReward(res.block.sizeMedian, res.block.transactionsCumulativeSize, prevBlockGeneratedCoins, 0, penalizeFee, currentReward, emissionChange)) {",
                            "    return false;",
                            "  }",
                            "",
                            "  res.block.baseReward = maxReward;",
                            "  if (maxReward == 0 && currentReward == 0) {",
                            "    res.block.penalty = static_cast<double>(0);",
                            "  } else {",
                            "    if (maxReward < currentReward) {",
                            "      return false;",
                            "    }",
                            "    res.block.penalty = static_cast<double>(maxReward - currentReward) / static_cast<double>(maxReward);",
                            "  }",
                            "",
                            "  // Base transaction adding",
                            "  f_transaction_short_response transaction_short;",
                            "  transaction_short.hash = Common::podToHex(getObjectHash(blk.baseTransaction));",
                            "  transaction_short.fee = 0;",
                            "  transaction_short.amount_out = get_outs_money_amount(blk.baseTransaction);",
                            "  res.block.transactions.push_back(transaction_short);",
                            "",
                            "",
                            "  std::list<Crypto::Hash> missed_txs;",
                            "  std::list<Transaction> txs;",
                            "  m_core.getTransactions(blk.transactionHashes, txs, missed_txs);",
                            "",
                            "  res.block.totalFeeAmount = 0;",
                            "",
                            "  for (const Transaction& tx : txs) {",
                            "    f_transaction_short_response transaction_short;",
                            "    uint64_t amount_in = 0;",
                            "    get_inputs_money_amount(tx, amount_in);",
                            "    uint64_t amount_out = get_outs_money_amount(tx);",
                            "",
                            "    transaction_short.hash = Common::podToHex(getObjectHash(tx));",
                            "    transaction_short.fee = amount_in - amount_out;",
                            "    transaction_short.amount_out = amount_out;",
                            "    transaction_short.size = getObjectBinarySize(tx);",
                            "    res.block.transactions.push_back(transaction_short);",
                            "",
                            "    res.block.totalFeeAmount += transaction_short.fee;",
                            "  }",
                            "",
                            "  res.status = CORE_RPC_STATUS_OK;",
                            "  return true;",
                            "}",
                            "",
                            "bool RpcServer::f_on_transaction_json(const F_COMMAND_RPC_GET_TRANSACTION_DETAILS::request& req, F_COMMAND_RPC_GET_TRANSACTION_DETAILS::response& res) {",
                            "  Hash hash;",
                            "",
                            "  if (!parse_hash256(req.hash, hash)) {",
                            "    throw JsonRpc::JsonRpcError{",
                            "      CORE_RPC_ERROR_CODE_WRONG_PARAM,",
                            "      \"Failed to parse hex representation of transaction hash. Hex = \" + req.hash + '.' };",
                            "  }",
                            "",
                            "  std::vector<Crypto::Hash> tx_ids;",
                            "  tx_ids.push_back(hash);",
                            "",
                            "  std::list<Crypto::Hash> missed_txs;",
                            "  std::list<Transaction> txs;",
                            "  m_core.getTransactions(tx_ids, txs, missed_txs);",
                            "",
                            "  if (1 == txs.size()) {",
                            "    res.tx = txs.front();",
                            "  } else {",
                            "    throw JsonRpc::JsonRpcError{",
                            "      CORE_RPC_ERROR_CODE_WRONG_PARAM,",
                            "      \"transaction wasn't found. Hash = \" + req.hash + '.' };",
                            "  }",
                            "",
                            "  Crypto::Hash blockHash;",
                            "  uint32_t blockHeight;",
                            "  if (m_core.getBlockContainingTx(hash, blockHash, blockHeight)) {",
                            "    Block blk;",
                            "    if (m_core.getBlockByHash(blockHash, blk)) {",
                            "      size_t tx_cumulative_block_size;",
                            "      m_core.getBlockSize(blockHash, tx_cumulative_block_size);",
                            "      size_t blokBlobSize = getObjectBinarySize(blk);",
                            "      size_t minerTxBlobSize = getObjectBinarySize(blk.baseTransaction);",
                            "      f_block_short_response block_short;",
                            "",
                            "      block_short.cumul_size = blokBlobSize + tx_cumulative_block_size - minerTxBlobSize;",
                            "      block_short.timestamp = blk.timestamp;",
                            "      block_short.height = blockHeight;",
                            "      block_short.hash = Common::podToHex(blockHash);",
                            "      block_short.cumul_size = blokBlobSize + tx_cumulative_block_size - minerTxBlobSize;",
                            "      block_short.tx_count = blk.transactionHashes.size() + 1;",
                            "      res.block = block_short;",
                            "    }",
                            "  }",
                            "",
                            "  uint64_t amount_in = 0;",
                            "  get_inputs_money_amount(res.tx, amount_in);",
                            "  uint64_t amount_out = get_outs_money_amount(res.tx);",
                            "",
                            "  res.txDetails.hash = Common::podToHex(getObjectHash(res.tx));",
                            "  res.txDetails.fee = amount_in - amount_out;",
                            "  if (amount_in == 0)",
                            "    res.txDetails.fee = 0;",
                            "  res.txDetails.amount_out = amount_out;",
                            "  res.txDetails.size = getObjectBinarySize(res.tx);",
                            "",
                            "  uint64_t mixin;",
                            "  if (!f_getMixin(res.tx, mixin)) {",
                            "    return false;",
                            "  }",
                            "  res.txDetails.mixin = mixin;",
                            "",
                            "  Crypto::Hash paymentId;",
                            "  if (CryptoNote::getPaymentIdFromTxExtra(res.tx.extra, paymentId)) {",
                            "    res.txDetails.paymentId = Common::podToHex(paymentId);",
                            "  } else {",
                            "    res.txDetails.paymentId = \"\";",
                            "  }",
                            "",
                            "  res.status = CORE_RPC_STATUS_OK;",
                            "  return true;",
                            "}",
                            "",
                            "bool RpcServer::f_getMixin(const Transaction& transaction, uint64_t& mixin) {",
                            "  mixin = 0;",
                            "  for (const TransactionInput& txin : transaction.inputs) {",
                            "    if (txin.type() != typeid(KeyInput)) {",
                            "      continue;",
                            "    }",
                            "    uint64_t currentMixin = boost::get<KeyInput>(txin).outputIndexes.size();",
                            "    if (currentMixin > mixin) {",
                            "      mixin = currentMixin;",
                            "    }",
                            "  }",
                            "  return true;",
                            "}"
                        ]
                    }
                }
            ]
        }
    ]
}